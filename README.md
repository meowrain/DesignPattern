[TOC]

# 面向对象相关知识

面向对象类关系(继承、实现、依赖、关联、聚合、组合)：https://www.cnblogs.com/zhongj/p/11169780.html

UML: https://blog.csdn.net/quyingzhe0217/article/details/133683814

# 创建型模式

工厂方法模式

抽象工厂模式

生成器模式

原型模式

单例模式

# 结构型模式

# 行为模式

## 工厂方法模式 factory_method

工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

问题：
假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为 卡车的类中。

一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能。

这可是个好消息。 但是代码问题该如何处理呢？ 目前， 大部分代码都与 卡车类相关。 在程序中添加 轮船类需要修改全部代码。 更糟糕的是，
如果你以后需要在程序中支持另外一种运输方式， 很可能需要再次对这些代码进行大幅修改。

最后， 你将不得不编写繁复的代码， 根据不同的运输对象类， 在应用中进行不同的处理。

解决方案：

![](https://static.meowrain.cn/i/2024/04/29/10js1xv-3.webp)

乍看之下， 这种更改可能毫无意义： 我们只是改变了程序中调用构造函数的位置而已。 但是， 仔细想一下， 现在你可以在子类中重写工厂方法，
从而改变其创建产品的类型。

但有一点需要注意:仅当这些产品具有共同的基类或者接口时， 子类才能返回不同类型的产品， 同时基类中的工厂方法还应将其返回类型声明为这一共有接口。

![](https://static.meowrain.cn/i/2024/04/29/10kjkci-3.webp)

举例来说， 卡车Truck和 轮船Ship类都必须实现 运输Transport接口， 该接口声明了一个名为 deliver交付的方法。 每个类都将以不同的方式实现该方法：
卡车走陆路交付货物， 轮船走海路交付货物。 陆路运输RoadLogistics类中的工厂方法返回卡车对象， 而
海路运输SeaLogistics类则返回轮船对象。

调用工厂方法的代码 （通常被称为客户端代码） 无需了解不同子类返回实际对象之间的差别。 客户端将所有产品视为抽象的 运输 。
客户端知道所有运输对象都提供 交付方法， 但是并不关心其具体实现方式。

以上的实现已经写在`factory_method`文件夹里面了
Logistics相当于下面的Creator,RoadLogistic和SeaLogistic相当于ConcreteCreatorA和ConcreteCreatorB
Transport相当于Product接口，下面的Ship和Truck是实现这个接口的实体类

![](https://static.meowrain.cn/i/2024/04/29/10sdlxc-3.webp)

### 工厂方法应用场景：

当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。

工厂方法将创建产品的代码与实际使用产品的代码分离， 从而能在不影响其他代码的情况下扩展产品创建部分代码。

例如， 如果需要向应用中添加一种新产品， 你只需要开发新的创建者子类， 然后重写其工厂方法即可。

就像上面我们写的运输货物的例子一样，假如现在多出个飞机运输，我们只需要创建一个`AirPlane类`，然后让它implements
`Transport接口`，实现其中的`transport函数`就可以了

同时需要创建一个`FlightLogistic`，继承`Logistics抽象类`，然后重写就可以

----

如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。

继承可能是扩展软件库或框架默认行为的最简单方法。 但是当你使用子类替代标准组件时， 框架如何辨识出该子类？

解决方案是将各框架中构造组件的代码集中到单个工厂方法中， 并在继承该组件之外允许任何人对该方法进行重写。

让我们看看具体是如何实现的。 假设你使用开源 UI 框架编写自己的应用。 你希望在应用中使用圆形按钮， 但是原框架仅支持矩形按钮。
你可以使用 圆形按钮RoundButton子类来继承标准的 按钮Button类。 但是， 你需要告诉 UI框架UIFramework类使用新的子类按钮代替默认按钮。
为了实现这个功能， 你可以根据基础框架类开发子类 圆形按钮 UIUIWithRoundButtons ， 并且重写其 createButton创建按钮方法。
基类中的该方法返回 按钮对象， 而你开发的子类返回 圆形按钮对象。 现在， 你就可以使用 圆形按钮 UI类代替 UI框架类。 就是这么简单！

---

如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。
在处理大型资源密集型对象 （比如数据库连接、 文件系统和网络资源） 时， 你会经常碰到这种资源需求。

让我们思考复用现有对象的方法：

    首先， 你需要创建存储空间来存放所有已经创建的对象。
    当他人请求一个对象时， 程序将在对象池中搜索可用对象。
    … 然后将其返回给客户端代码。
    如果没有可用对象， 程序则创建一个新对象 （并将其添加到对象池中）。

这些代码可不少！ 而且它们必须位于同一处， 这样才能确保重复代码不会污染程序。

可能最显而易见， 也是最方便的方式， 就是将这些代码放置在我们试图重用的对象类的构造函数中。 但是从定义上来讲， 构造函数始终返回的是新对象，
其无法返回现有实例。

因此， 你需要有一个既能够创建新对象， 又可以重用现有对象的普通方法。 这听上去和工厂方法非常相像。

![](https://static.meowrain.cn/i/2024/04/29/128oyga-3.webp)

### 优缺点

![](https://static.meowrain.cn/i/2024/04/29/111e7we-3.webp)

## 生成器模式

生成器模式是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。

问题
假设有这样一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。
这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中； 甚至还有更糟糕的情况， 那就是这些代码散落在客户端代码的多个位置。
![](https://static.meowrain.cn/i/2024/04/29/112vdzz-3.webp)
如果为每种可能的对象都创建一个子类， 这可能会导致程序变得过于复杂。
例如， 我们来思考如何创建一个 房屋House对象。 建造一栋简单的房屋， 首先你需要建造四面墙和地板， 安装房门和一套窗户，
然后再建造一个屋顶。 但是如果你想要一栋更宽敞更明亮的房屋， 还要有院子和其他设施 （例如暖气、 排水和供电设备）， 那又该怎么办呢？

最简单的方法是扩展 房屋基类， 然后创建一系列涵盖所有参数组合的子类。 但最终你将面对相当数量的子类。 任何新增的参数 （例如门廊类型）
都会让这个层次结构更加复杂。

另一种方法则无需生成子类。 你可以在 房屋基类中创建一个包括所有可能参数的超级构造函数， 并用它来控制房屋对象。
这种方法确实可以避免生成子类， 但它却会造成另外一个问题。

![](https://static.meowrain.cn/i/2024/04/29/113gdhw-3.webp)

拥有大量输入参数的构造函数也有缺陷： 这些参数也不是每次都要全部用上的。

通常情况下， 绝大部分的参数都没有使用， 这使得对于构造函数的调用十分不简洁。 例如， 只有很少的房子有游泳池，
因此与游泳池相关的参数十之八九是毫无用处的。

解决方案：
生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为生成器的独立对象中。

![](https://static.meowrain.cn/i/2024/04/29/113qrau-3.webp)

该模式会将对象构造过程划分为一组步骤， 比如 buildWalls创建墙壁和 buildDoor创建房门创建房门等。 每次创建对象时，
你都需要通过生成器对象执行一系列步骤。 重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。

当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。 例如， 木屋的房门可能需要使用木头制造，
而城堡的房门则必须使用石头制造。

在这种情况下， 你可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 然后你就可以在创建过程中使用这些生成器
（例如按顺序调用多个构造步骤） 来生成不同类型的对象。

例如， 假设第一个建造者使用木头和玻璃制造房屋， 第二个建造者使用石头和钢铁， 而第三个建造者使用黄金和钻石。 在调用同一组步骤后，
第一个建造者会给你一栋普通房屋， 第二个会给你一座小城堡， 而第三个则会给你一座宫殿。 但是，
只有在调用构造步骤的客户端代码可以通过通用接口与建造者进行交互时， 这样的调用才能返回需要的房屋。


---

主管

你可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。 主管类可定义创建步骤的执行顺序， 而生成器则提供这些步骤的实现。

严格来说， 你的程序中并不一定需要主管类。 客户端代码可直接以特定顺序调用创建步骤。 不过， 主管类中非常适合放入各种例行构造流程，
以便在程序中反复使用。

此外， 对于客户端代码来说， 主管类完全隐藏了产品构造细节。 客户端只需要将一个生成器与主管类关联， 然后使用主管类来构造产品，
就能从生成器处获得构造结果了。

![](https://static.meowrain.cn/i/2024/04/29/1165d0g-3.webp)

在文件夹`builder_patter`
中，我创建了House实体类，对应结构中的Client，HouseBuilder接口对应其中的Builder,产品为Roof,Wall,Door,Window，分别在ConcretHouseBuilder中进行建造，ConcretHouseBuilder实现了HouseBuilder接口。

HouseBuilderEngineer对应图中的主管，负责定义构造步骤的顺序。

![](https://static.meowrain.cn/i/2024/04/29/128ixkd-3.webp)